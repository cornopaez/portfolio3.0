<meta name="keywords" content="ssl tls pihole pi-hole ad blocker jupyterlab jupyter notbook local home lab custom domains domain acme.sh">
<meta name="description" content="How to enable SSL/TLS for your local lab and apps, including Pi-Hole and JupyterLab, using a custom domain.">
<meta name="author" content="Mauricio Paez - Developer">
<div class="btn-container">
  <a routerLink="/Musings" class="btn btn-link"><i class="fas fa-chevron-left"></i>  Back to Musings</a>  
</div>

<div class="jumbotron">
  <div class="footnotes">
    <h4>Tech used</h4>
    <ul>
      <li *ngFor="let icon of currentContent.content.icons">
        <i class="{{icon}}"></i>
      </li>
    </ul>
  </div>
</div>

<!-- Photo by <a href="https://unsplash.com/@markuswinkler?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Markus Winkler</a> on <a href="https://unsplash.com/photos/brown-padlock-on-brown-wooden-post-SZ98vfIx0pw?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a> -->
  
<div class="detail project-detail">
  <h1>How to enable SSL/TLS for your local lab and apps, including Pi-Hole and JupyterLab, using a custom domain</h1>
  <small class="text-muted">Updated 2024-04-25</small><br>
  <small class="text-muted">Photo by <a href="https://unsplash.com/@markuswinkler">Markus Winkler</a> on Unsplash</small>
  <br>
  <br>
  <div class="project-container">
    <p>This guide walks you through setting up SSL/TLS for your home lab and apps, specifically focusing on securing the web interface of Pi-Hole (a well-known ad-blocking app) and JupyterLab (a well-known Python development app). Of course, the steps taken here should help you figure out how to secure other local apps as well -- the skills are universal.</p>
    <p>This guide assumes you have a domain registered with Cloudflare. It also asumes that you have fully functional Pi-Hole and JupyterLab instances in an Ubuntu server. However, the instructions may be applicable or modified accordingly for other OS. On the other hand, you do not need to know about <kbd>acme.sh</kbd> which we'll use to generate the certs. If you do not know where to start on Pi-Hole and JupyterLab, these links should help you get started:</p>
    <ul>
      <li>
        <a href="https://pi-hole.net/">Official Pi-Hole Page</a>
      </li>
      <li>
        <a href="https://jupyter.org/">Official JupyterLab Page</a>
      </li>
    </ul>
    <h2>Table of Contents</h2>
    <ol>
      <li>
        <a routerLink="../tls-for-local-lab" fragment="intro">Intro. Also, why do this?</a>
      </li>
      <li>
        <a routerLink="../tls-for-local-lab" fragment="acme"><kbd>acme.sh</kbd> Setup</a>
      </li>
      <ul>
        <li>
          <a routerLink="../tls-for-local-lab" fragment="acme-command"><code>acme.sh</code> command</a>
        </li>
        <li>
          <a routerLink="../tls-for-local-lab" fragment="acme-post-hook"><code>post-hook</code> file</a>
        </li>
        <li>
          <a routerLink="../tls-for-local-lab" fragment="acme-pre-hook">Notes about the <code>pre-hook</code> file</a>
        </li>
        <li>
          <a routerLink="../tls-for-local-lab" fragment="acme-cf-zone-token">Cloudflare Zone ID and API Token</a>
        </li>
        <li>
          <a routerLink="../tls-for-local-lab" fragment="acme-command-run">Run the <code>acme.sh</code> command</a>
        </li>
      </ul>
      <li>
        <a routerLink="../tls-for-local-lab" fragment="pi-hole">Pi-Hole Setup</a>
      </li>
      <li>
        <a routerLink="../tls-for-local-lab" fragment="jupyterlab">JupyterLab Setup</a>
      </li>
      <li>
        <a routerLink="../tls-for-local-lab" fragment="musings">Musings</a>
      </li>
    </ol>
    <br>
    <h2 id="intro">Intro. Also, why do this?</h2>
    <p>
      This guide makes little sense for some. The two apps I list in this guide, after all, are usually internal apps (inside of your firewall) and, as such, an SSL/TLS certificate should not be needed. This was true in the past, back in the days when browsers were not defaulting to secure connections and displaying warnings about visiting sites without them. However, browsers now display those warnings by default which are annoying but do protect our valudable and sensitive information from prying eyes. 
    </p>
    <p> 
      Of course, you still can just click through the prompts to visit your site and forget about it. But, why not do things properly? If you're here, you are likely already on board and, to that end, let's spend the 10 minutes this guide takes to implement. If not, let's spend 10 minutes anyways getting you setup.
    </p>

    <h2 id="acme"><kbd>acme.sh</kbd> Setup</h2>
    <h3 id="acme-command"><code>acme.sh</code> command</h3>
    <p>
      As the first step, let's work on the certificates first. We'll be using <kbd>acme.sh</kbd> to create them but you could also use <kbd>certbot</kbd> (though we don't cover that here). Go ahead and download <kbd>acme.sh</kbd> according to their instructions on their <a href="https://github.com/acmesh-official/acme.sh">official GitHub repo</a>. It is good practice to avoid piping scripts into bash (though, convenient it is). Use whichever method you prefer. We'll run all the commands as <code>root</code> since it's recommended by the software itself. You may look for better ways to do this once you've gotten the process down.
    </p>
    <p>
      Note that the software, unlike other, does not need a manual config file. It also does not need to be manually configured to renew certs when the time is right. By running the commands below, the creation of the certs, adding them to the local <kbd>acme.sh</kbd> db, and renewing when necessary will be taken care of automatically. It even includes a cool feature to run custom scripts before and after the creation or refreshing of certs! This was not plainly obvious in their documentation and it is worth spelling out for novices like me.
    </p>
    <p>With this in mind, let's break down the command we'll be issuing once <kbd>acme.sh</kbd> is installed. <b>NOTE: DON'T RUN THIS COMMAND YET!</b></p>

    <p>
      <code>
        acme.sh --issue --dns dns_cf -d mycustomdomain.local -d '*.mycustomdomain.local' --server letsencrypt --pre-hook /usr/local/bin/acme-pre.sh --post-hook /usr/local/bin/acme-post.sh
      </code>
      <br><br>
      <mat-table [dataSource]="currentContent.acme_commands" class="mat-elevation-z8">
        <ng-container matColumnDef="parameter">
          <th mat-header-cell *matHeaderCellDef> Parameter </th>
          <td mat-cell *matCellDef="let command"> {{command.parameter}} </td>
        </ng-container>

        <ng-container matColumnDef="description">
          <th mat-header-cell *matHeaderCellDef> Description </th>
          <td mat-cell *matCellDef="let command"> {{command.description}} </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="currentContent.columnsToDisplay"></tr>
        <tr mat-row *matRowDef="let row; columns: currentContent.columnsToDisplay;"></tr>
      </mat-table>
    </p>
    <p>
      Of course, you may not need <kbd>pre-hook</kbd> or <kbd>post-hook</kbd> scripts for other tech stacks -- you can certainly adapt that command to suit your needs. However, in this case, we will need at least the <kbd>post-hook</kbd> script to compile the combined keys file Pi-Hole needs, move it into place, and restart <code>lighttpd</code> so it can pick up the newly created file. The <kbd>pre-hook</kbd> and <kbd>post-hook</kbd> files <b>must</b> exist but don't need to have anything in them at the time the command is run and, as such, you can fill them later. Failure to create the files results in having to start again from scratch for this domain. Don't forget to create them!
    </p>
    <h3 id="acme-post-hook"><code>post-hook</code> file</h3>
    <p>
      Let's create the file we're going to be using for the <code>post-hook</code>.
    </p>
    <p>
      First, let's move to <kbd>sudo</kbd> using the following command:<br>
      <code>sudo su</code>
    </p>
    <p>
      Then, let's create the file:<br>
      <code>nano /usr/local/bin/acme-post.sh</code>
    </p>
    <p>
      The contents of the file, with replacements for your own domain, are as follows:
    </p>
    <pre>
<span class="hash-bang">#!/bin/bash</span>

<span class="bash-comment"># Combine cert and key for lighttpd</span>
<span class="bash-command">cat</span> /root/.acme.sh/mycustomdomain.local_ecc/mycustomdomain.local.key /root/.acme.sh/mycustomdomain.local_ecc/mycustomdomain.local.cer > /root/.acme.sh/mycustomdomain.local_ecc/combined.pem

<span class="bash-comment"># Make backup of old key</span>
<span class="bash-command">mv</span> /etc/lighttpd/combined.pem /etc/lighttpd/combined.pem.old

<span class="bash-comment"># Move new key into place</span>
<span class="bash-command">mv</span> /root/.acme.sh/mycustomdomain.local_ecc/combined.pem /etc/lighttpd/combined.pem

<span class="bash-comment"># Restart lighttpd</span>
<span class="bash-command">service</span> lighttpd restart
    </pre>  
    <p>
      Finally, let's make sure that the file has execution permissions:<br>
      <code>chmod +x /usr/local/bin/acme-post.sh</code>
    </p>
    <h3 id="acme-pre-hook">Notes about the <code>pre-hook</code> file</h3>
    The instructions above for the <kbd>post-hook</kbd> file can be used to create a <kbd>pre-hook</kbd> file all the same. I will not include a template for such a file here since there's no use for it in this guide. However, and this is very important, <b><i>the file should be created prior to running the <kbd>acme.sh</kbd> command. Failure to do so will result in you having to start over again or figure out how to add it to the config file manually (which is not easy).</i></b>
    <h3 id="acme-cf-zone-token">Cloudflare Zone ID and API Token</h3>
    <p>
      Now that we have everything lined up, the command has been crafted, the files have been created and/or populated, we are almost ready to run the command.
    </p>
    <p>
      The last piece of preparation we need is to get two pieces of data from Cloudflare: the Zone ID and the API Token. To fetch those, log into your Cloudflare dashboard. For the Zone ID, it can be found in the <kbd>domain</kbd> overview page, right hand side, near the bottom of the page:
    </p>
    <div class="cloudflare">
      <img src="{{currentContent.content.cloudflare[0].img}}" alt="{{currentContent.content.cloudflare[0].alt}}">
    </div>
    <p>
      Note that there's a handy link to get an API token right there. Click it and then hit the <kbd>Create Token</kbd> button:
    </p>
    <div class="cloudflare">
      <img src="{{currentContent.content.cloudflare[1].img}}" alt="{{currentContent.content.cloudflare[1].alt}}">
    </div>
    <p>
      When creating the token, make sure you select the appropriate zone and permissions needed. You'll need <kbd>read</kbd> and <kbd>write</kbd> permissions. To this end, be sure to keep this token safe as it can seriously mess up your domain.
    </p>
    <p>
      Once you've gotten your API Token and your Zone ID, issue the following commands in your terminal to load the values as environment variables:
    </p>
    <pre>
export CF_Token="[your_token_goes_here]"
export CF_Zone_ID="[your_zone_id_goes_here]"
    </pre>
    <h3 id="acme-command-run">Run the <code>acme.sh</code> command</h3>
    <p>
      We are now ready to run the command. However, if you are unsure as to what we've done so far, here's a quick refresher:
    </p>
    <pre>
<span class="bash-comment"># Move to root</span>
<span class="bash-command">sudo</span> su

<span class="bash-comment"># Create the post-hook script and populate with template above</span>
<span class="bash-command">nano</span> /usr/local/bin/acme-post.sh

<span class="bash-comment"># Modify file properties to enable execution</span>
<span class="bash-command">chmod</span> +x /usr/local/bin/acme-post.sh

<span class="bash-comment"># Export Cloudflare's API Token and Zone ID as environment variables</span>
<span class="bash-command">export</span> CF_Token="[your_token_goes_here]"
<span class="bash-command">export</span> CF_Zone_ID="[your_zone_id_goes_here]"
    </pre>
    <p>
      To those commands, we'll add the following one that actually fetches the certificates and keys. Replace your domain accordingly:
    </p>
    <pre>
<span class="bash-command">acme.sh</span> --issue --dns dns_cf -d mycustomdomain.local -d '*.mycustomdomain.local' --server letsencrypt --post-hook /usr/local/bin/acme-post.sh
    </pre>
    <p>
      If all went well, the output would look something like this:
    </p>
    <pre>
[Tue Apr 23 11:35:25 EDT 2024] Using CA: https://acme-v02.api.letsencrypt.org/directory
[Tue Apr 23 11:35:25 EDT 2024] Creating domain key
[Tue Apr 23 11:35:25 EDT 2024] The domain key is here: <span class="code-green">/root/.acme.sh/mycustomdomain.local_ecc/mycustomdomain.local.key</span>
[Tue Apr 23 11:35:25 EDT 2024] Multi domain='DNS:mycustomdomain.local,DNS:*.mycustomdomain.local'
[Tue Apr 23 11:35:27 EDT 2024] Getting webroot for domain='mycustomdomain.local'
[Tue Apr 23 11:35:27 EDT 2024] Getting webroot for domain='*.mycustomdomain.local'
[Tue Apr 23 11:35:28 EDT 2024] mycustomdomain.local is already verified, skip dns-01.
[Tue Apr 23 11:35:28 EDT 2024] *.mycustomdomain.local is already verified, skip dns-01.
[Tue Apr 23 11:35:28 EDT 2024] Verify finished, start to sign.
[Tue Apr 23 11:35:28 EDT 2024] Lets finalize the order.
[Tue Apr 23 11:35:28 EDT 2024] Le_OrderFinalize='https://acme-v02.api.letsencrypt.org/acme/finalize/[number_goes_here]/[number_goes_here]'
[Tue Apr 23 11:35:29 EDT 2024] Downloading cert.
[Tue Apr 23 11:35:29 EDT 2024] Le_LinkCert='https://acme-v02.api.letsencrypt.org/acme/cert/[long_number_goes_here]'
[Tue Apr 23 11:35:29 EDT 2024] <span class="code-green">Cert success.</span>
-----BEGIN CERTIFICATE-----
<span class="bash-comment"># Certificate in plaintext goes here</span>
-----END CERTIFICATE-----
[Tue Apr 23 11:35:29 EDT 2024] Your cert is in: <span class="code-green">/root/.acme.sh/mycustomdomain.local_ecc/mycustomdomain.local.cer</span>
[Tue Apr 23 11:35:29 EDT 2024] Your cert key is in: <span class="code-green">/root/.acme.sh/mycustomdomain.local_ecc/mycustomdomain.local.key</span>
[Tue Apr 23 11:35:29 EDT 2024] The intermediate CA cert is in: <span class="code-green">/root/.acme.sh/mycustomdomain.local_ecc/ca.cer</span>
[Tue Apr 23 11:35:29 EDT 2024] And the full chain certs is there: <span class="code-green">/root/.acme.sh/mycustomdomain.local_ecc/fullchain.cer</span>
    </pre>
    <p>
      There's a possibility the output includes an error that reads <code>/etc/lighttpd/combined.pem: path or file does not exist.</code> This is expected, as the first time the script runs the file does not exist. Afterwards, though, the file does and the error is not going to be around anymore.
    </p>
    <p>
      Also, since my local <kbd>acme.sh</kbd> had already the domain I used to capture outputs for this guide, there's some steps in the output that are missing. If the domain needs to be verified for the first time, validation entries in Cloudflare will appear in the output. You'll also see timers in place to wait for changes to propagate prior to attempting the validation. All of this is normal.
    </p>
    <h2 id="pi-hole">Pi-Hole Setup</h2>
    <p>
      Now that we have certs, let's setup Pi-Hole's web UI to use the cert we've created. You may notice that part of the <code>post-hook</code> file was to combine the <kbd>key</kbd> and <kbd>cer</kbd> files into a single one. This was done because <kbd>lighttpd</kbd> requires such a file in order to work correctly and it is not provided by <kbd>acme.sh</kbd> by default. You may also notice we placed the combined file in <kbd>lighttpd</kbd>'s folder under <kbd>/etc</kbd>. You don't need to put it there but it helps since <kbd>lighttpd</kbd> is already the owner of that folder and you don't have to work too hard to make sure the permissions are correct.
    </p>
    <h3>Update your local or Cloudflare DNS settings</h3>
    <p>
      Since we're going to use an SSL/TLS connection to serve PI-Hole's UI, we need to make sure that your DNS settings are updated accordingly. The certificate we've created needs the domain in the URL to match its contents. This means we can't hit the IP address of the box running Pi-Hole directly and get served over SSL/TLS.
    </p>
    <p>
      Pi-Hole allows you to create your own local DNS entries and that can be one way to ensure the domain matches. Just navigate to the <kbd>Local DNS</kbd> tab on the right hand, and then click on <kbd>DNS Entries</kbd>. Add and entry for the IPv4 address and one for the IPv6 address (if applicable) of the box that's running Pi-Hole:
    </p>
    <div class="pihole">
      <img src="{{currentContent.content.pihole[0].img}}" alt="{{currentContent.content.pihole[0].alt}}">
    </div>
    <div class="pihole">
      <img src="{{currentContent.content.pihole[1].img}}" alt="{{currentContent.content.pihole[1].alt}}">
    </div>
    <p>
      If you have not done so, this would be a good time to set a static IPv4 address for your Pi-hole box -- that is, if it's hosted locally, inside your network and not somewhere like AWS. If you're running IPv6 in your home network, it's best to use <kbd>ddclient</kbd> or any other to Dynamic DNS softwarde to update the DNS settings of your domain at your registrar. Since IPv6 addresses are global in nature, you don't have to worry about setting a static IPv6 locally. This is ideal for ISPs that like to switch IPv6 prefixes to avoid giving people static prefixes (for which they charge money). Plus, you can still set the static IPv4 there -- even if it's in the reserved blocks of addresses like 10.0.0.0/8 or 192.168.0.0/8.
    </p>
    <h3>Installing a new <kbd>lighttpd</kbd> version</h3>
    <p>
      As of 2024-04-15, the default Pi-Hole installation does not install a version of <kbd>lighttpd</kbd> that includes the <code>mod_openssl</code> module it needs to serve the site using SSL/TLS certificates. To this end, we'll start by installing backing up Pi-Hole's <kbd>lighttpd.conf</kbd> and then install a new version of <kbd>lighttpd</kbd>:
    </p>
    <pre>
<span class="bash-comment"># You may need to run all of this as root to avoid permissions issues</span>

<span class="bash-comment"># Backup the existing lighttpd.conf file to avoid losing Pi-Hole's configs</span>
<span class="bash-command">cp</span> /etc/lighttpd/lightpd.conf /etc/lighttpd/lightpd.conf.og 

<span class="bash-comment"># Install new version of lighttpd that includes the openSSL module</span>
<span class="bash-command">apt</span> install lighttpd-mod-openssl

<span class="bash-comment"># Stop service to replace config files</span>
<span class="bash-command">service</span> lighttpd stop

<span class="bash-comment"># Replace OG lighttpd.conf since it was likely replaced by the install</span>
<span class="bash-command">mv</span> /etc/lighttpd/lightpd.conf /etc/lighttpd/lightpd.conf.new 
<span class="bash-command">mv</span> /etc/lighttpd/lightpd.conf.og /etc/lighttpd/lightpd.conf 

<span class="bash-comment"># Start service</span>
<span class="bash-command">service</span> lighttpd start
    </pre>
    <p>
      Once the package is installed and you have verified the service is up and running without issues, we'll need to create the following file (if it doesn't exist already) to ensure that <kbd>lighttpd</kbd> serves the UI without issues: <code>/etc/lighttpd/external.conf</code>. Use the following template to fill that new file in:
    </p>
    <pre>
<span class="bash-comment">#Loading openssl</span>
server.modules += ( "mod_openssl" )

<span class="bash-comment"># Enable ipv6 -- Optional. Requires IPv6 config in network.</span>
#server.use-ipv6 = "enable"

<span class="bash-comment"># Ensure the Pi-hole Block Page knows that this is not a blocked domain</span>
setenv.add-environment = ("fqdn" => "true")

<span class="bash-comment"># Enable the SSL engine with a cert for IPv4, only for this specific host</span>
$SERVER["socket"] == ":8443" {{ '{' }} <span class="bash-comment"># Update your port accordingly.</span>
  ssl.engine = "enable"
  ssl.pemfile = "/etc/lighttpd/combined.pem"
{{ '}' }}

<span class="bash-comment"># Enable the SSL engine with a cert for IPv6, only for this specific host  -- Optional. Requires IPv6 config in network.</span>
$SERVER["socket"] == "[::]:8443" {{ '{' }} <span class="bash-comment"># Update your port accordingly.</span>
        ssl.engine = "enable"
        ssl.pemfile = "/etc/lighttpd/combined.pem"
{{ '}' }}

<span class="bash-comment"># Redirect HTTP to HTTPS</span>
$HTTP["scheme"] == "http" {{ '{' }}
  $HTTP["host"] =~ ".*" {{ '{' }}
    url.redirect = (".*" => "https://%0$0")
  {{ '}' }}
{{ '}' }}
    </pre>
    <p>
      Once the file is populated, go ahead and restart <kbd>lighttpd</kbd>. If all went well, the service should come up without errors and you should be able to hit Pi-Hole's UI while it being served with an SSL/TLS connection.
    </p>
    <h2 id="jupyterlab">JupyterLab Setup</h2>

    <h2 id="musings">Musings</h2>

	</div>
</div>